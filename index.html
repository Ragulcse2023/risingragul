<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Games Hub: Shuttle Table, Chess, Sudoku</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0; padding: 0;
  }
  header {
    background: #222;
    padding: 10px 0;
    text-align: center;
  }
  header h1 {
    margin: 0;
    font-weight: normal;
  }
  nav {
    display: flex;
    justify-content: center;
    background: #333;
  }
  nav button {
    flex: 1;
    padding: 12px;
    font-size: 16px;
    cursor: pointer;
    background: #444;
    border: none;
    color: white;
    transition: background 0.3s;
  }
  nav button.active, nav button:hover {
    background: #66bb6a;
  }
  main {
    max-width: 700px;
    margin: 20px auto;
    padding: 0 10px 30px;
    background: #1e1e1e;
    border-radius: 8px;
  }
  section {
    display: none;
  }
  section.active {
    display: block;
  }
  /* Shuttle Table styles */
  #pong {
    background: black;
    display: block;
    margin: 20px auto;
    border: 2px solid #fff;
    max-width: 100%;
  }
  /* Chess styles */
  table.chess {
    border-collapse: collapse;
    margin: 20px auto;
    user-select: none;
    outline: none;
  }
  table.chess td {
    width: 60px;
    height: 60px;
    text-align: center;
    vertical-align: middle;
    font-size: 40px;
    cursor: pointer;
    transition: background 0.2s;
  }
  table.chess td.white {
    background: #f0d9b5;
  }
  table.chess td.black {
    background: #b58863;
  }
  table.chess td.selected {
    outline: 3px solid #66bb6a;
  }
  table.chess td.possible-move {
    background-color: #a0d468 !important;
  }
  /* Sudoku styles */
  table.sudoku {
    border-collapse: collapse;
    margin: 20px auto;
    background: #222;
    border-radius: 5px;
    box-shadow: 0 0 10px #33cc66aa;
  }
  table.sudoku td {
    border: 1px solid #444;
    width: 40px;
    height: 40px;
    text-align: center;
    background: #333;
    position: relative;
  }
  table.sudoku td:nth-child(3), table.sudoku td:nth-child(6) {
    border-right: 3px solid #66bb6a;
  }
  table.sudoku tr:nth-child(3) td, table.sudoku tr:nth-child(6) td {
    border-bottom: 3px solid #66bb6a;
  }
  table.sudoku input {
    width: 38px;
    height: 38px;
    font-size: 20px;
    text-align: center;
    border: none;
    background: #222;
    color: #66bb6a;
    font-weight: bold;
    outline: none;
    transition: background-color 0.3s;
  }
  table.sudoku input:focus {
    background-color: #66bb6a;
    color: #121212;
  }
  table.sudoku input.error {
    background: #f44336;
    color: white;
    font-weight: bold;
  }
  button.check-btn {
    display: block;
    margin: 15px auto 30px;
    padding: 8px 15px;
    font-size: 16px;
    cursor: pointer;
    background: #66bb6a;
    border: none;
    color: white;
    border-radius: 5px;
    transition: background 0.3s;
  }
  button.check-btn:hover {
    background: #57a05a;
  }
  p.instructions {
    text-align: center;
    margin-top: 0;
    color: #ccc;
  }
</style>
</head>
<body>

<header>
  <h1>Games Hub</h1>
</header>
<nav>
  <button id="tab-pong" class="active">Shuttle Table</button>
  <button id="tab-chess">Chess</button>
  <button id="tab-sudoku">Sudoku</button>
</nav>

<main>
  <!-- Shuttle Table Pong -->
  <section id="pong-section" class="active">
    <h2 style="text-align:center;">Simple Shuttle Table Game (Pong)</h2>
    <canvas id="pong" width="600" height="400"></canvas>
    <p class="instructions">Use <b>W/S</b> for left paddle and <b>Up/Down Arrows</b> for right paddle.</p>
  </section>

  <!-- Chess -->
  <section id="chess-section">
    <h2 style="text-align:center;">Basic Chess Board</h2>
    <p style="text-align:center; color:#ccc; font-size:14px; margin-bottom:0;">
      Use arrow keys to move selection. Press <b>Enter</b> to select/move piece.
    </p>
    <table class="chess" aria-label="Chess board" tabindex="0">
      <tbody>
        <tr>
          <td class="black">&#9820;</td><td class="white">&#9822;</td><td class="black">&#9821;</td><td class="white">&#9819;</td>
          <td class="black">&#9818;</td><td class="white">&#9821;</td><td class="black">&#9822;</td><td class="white">&#9820;</td>
        </tr>
        <tr>
          <td class="white">&#9823;</td><td class="black">&#9823;</td><td class="white">&#9823;</td><td class="black">&#9823;</td>
          <td class="white">&#9823;</td><td class="black">&#9823;</td><td class="white">&#9823;</td><td class="black">&#9823;</td>
        </tr>
        <tr><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td></tr>
        <tr><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td></tr>
        <tr><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td></tr>
        <tr><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td><td class="white"></td><td class="black"></td></tr>
        <tr>
          <td class="black">&#9817;</td><td class="white">&#9817;</td><td class="black">&#9817;</td><td class="white">&#9817;</td>
          <td class="black">&#9817;</td><td class="white">&#9817;</td><td class="black">&#9817;</td><td class="white">&#9817;</td>
        </tr>
        <tr>
          <td class="white">&#9814;</td><td class="black">&#9816;</td><td class="white">&#9815;</td><td class="black">&#9813;</td>
          <td class="white">&#9812;</td><td class="black">&#9815;</td><td class="white">&#9816;</td><td class="black">&#9814;</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- Sudoku -->
  <section id="sudoku-section">
    <h2 style="text-align:center;">Simple Sudoku</h2>
    <table class="sudoku" id="sudoku-table" aria-label="Sudoku board">
      <tbody>
        <!-- grid generated by JS -->
      </tbody>
    </table>
    <button class="check-btn" id="check-btn">Check Sudoku</button>
  </section>
</main>

<script>
// Tab switching logic
const tabs = {
  pong: document.getElementById('tab-pong'),
  chess: document.getElementById('tab-chess'),
  sudoku: document.getElementById('tab-sudoku'),
};
const sections = {
  pong: document.getElementById('pong-section'),
  chess: document.getElementById('chess-section'),
  sudoku: document.getElementById('sudoku-section'),
};
function activateTab(name) {
  for (const key in tabs) {
    tabs[key].classList.toggle('active', key === name);
    sections[key].classList.toggle('active', key === name);
  }
}
tabs.pong.onclick = () => activateTab('pong');
tabs.chess.onclick = () => activateTab('chess');
tabs.sudoku.onclick = () => activateTab('sudoku');

// ------------------
// Pong Game code (unchanged)
// ------------------
const canvas = document.getElementById('pong');
const ctx = canvas.getContext('2d');

const paddleWidth = 10, paddleHeight = 100;
let leftPaddleY = canvas.height/2 - paddleHeight/2;
let rightPaddleY = canvas.height/2 - paddleHeight/2;
const paddleSpeed = 8;

const ballRadius = 10;
let ballX = canvas.width/2;
let ballY = canvas.height/2;
let ballSpeedX = 5;
let ballSpeedY = 3;

const keys = {};

document.addEventListener('keydown', e => { keys[e.key] = true; });
document.addEventListener('keyup', e => { keys[e.key] = false; });

function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
}

function drawCircle(x, y, r, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fill();
}

function drawNet() {
  for(let i = 0; i < canvas.height; i += 30) {
    drawRect(canvas.width/2 - 1, i, 2, 20, 'white');
  }
}

function update() {
  if(tabs.pong.classList.contains('active')) {
    // Move paddles
    if(keys['w'] && leftPaddleY > 0) leftPaddleY -= paddleSpeed;
    if(keys['s'] && leftPaddleY + paddleHeight < canvas.height) leftPaddleY += paddleSpeed;
    if(keys['ArrowUp'] && rightPaddleY > 0) rightPaddleY -= paddleSpeed;
    if(keys['ArrowDown'] && rightPaddleY + paddleHeight < canvas.height) rightPaddleY += paddleSpeed;

    // Move ball
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    // Top & bottom collision
    if(ballY + ballRadius > canvas.height || ballY - ballRadius < 0) {
      ballSpeedY = -ballSpeedY;
    }

    // Paddle collision
    if(ballX - ballRadius < paddleWidth) {
      if(ballY > leftPaddleY && ballY < leftPaddleY + paddleHeight) {
        ballSpeedX = -ballSpeedX;
        // Add some speed variation
        const deltaY = ballY - (leftPaddleY + paddleHeight/2);
        ballSpeedY = deltaY * 0.3;
      } else if(ballX - ballRadius < 0) {
        resetBall();
      }
    }
    if(ballX + ballRadius > canvas.width - paddleWidth) {
      if(ballY > rightPaddleY && ballY < rightPaddleY + paddleHeight) {
        ballSpeedX = -ballSpeedX;
        const deltaY = ballY - (rightPaddleY + paddleHeight/2);
        ballSpeedY = deltaY * 0.3;
      } else if(ballX + ballRadius > canvas.width) {
        resetBall();
      }
    }
  }
}

function resetBall() {
  ballX = canvas.width/2;
  ballY = canvas.height/2;
  // Random initial direction
  ballSpeedX = 5 * (Math.random() > 0.5 ? 1 : -1);
  ballSpeedY = 3 * (Math.random() > 0.5 ? 1 : -1);
}

function render() {
  if(tabs.pong.classList.contains('active')) {
    drawRect(0, 0, canvas.width, canvas.height, 'black');
    drawNet();
    drawRect(0, leftPaddleY, paddleWidth, paddleHeight, 'white');
    drawRect(canvas.width - paddleWidth, rightPaddleY, paddleWidth, paddleHeight, 'white');
    drawCircle(ballX, ballY, ballRadius, 'white');
  }
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

gameLoop();

// ------------------
// Sudoku code with updated styles (unchanged logic except style)
// ------------------

const sudokuTable = document.getElementById('sudoku-table').querySelector('tbody');

const sampleSudoku = [
  [5, 3, 0, 0, 7, 0, 0, 0, 0],
  [6, 0, 0, 1, 9, 5, 0, 0, 0],
  [0, 9, 8, 0, 0, 0, 0, 6, 0],
  [8, 0, 0, 0, 6, 0, 0, 0, 3],
  [4, 0, 0, 8, 0, 3, 0, 0, 1],
  [7, 0, 0, 0, 2, 0, 0, 0, 6],
  [0, 6, 0, 0, 0, 0, 2, 8, 0],
  [0, 0, 0, 4, 1, 9, 0, 0, 5],
  [0, 0, 0, 0, 8, 0, 0, 7, 9]
];

// Create Sudoku grid inputs
function createSudokuGrid() {
  sudokuTable.innerHTML = '';
  for(let r = 0; r < 9; r++) {
    const tr = document.createElement('tr');
    for(let c = 0; c < 9; c++) {
      const td = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.maxLength = 1;
      input.pattern = '[1-9]';
      input.autocomplete = 'off';

      if(sampleSudoku[r][c] !== 0) {
        input.value = sampleSudoku[r][c];
        input.disabled = true;
        input.style.color = '#999';
        input.style.fontWeight = 'normal';
      } else {
        input.value = '';
      }

      input.addEventListener('input', () => {
        if(!/^[1-9]$/.test(input.value)) {
          input.value = '';
        }
      });

      td.appendChild(input);
      tr.appendChild(td);
    }
    sudokuTable.appendChild(tr);
  }
}

createSudokuGrid();

document.getElementById('check-btn').onclick = () => {
  checkSudoku();
};

function checkSudoku() {
  // clear errors
  document.querySelectorAll('table.sudoku input').forEach(input => input.classList.remove('error'));

  // read grid
  const grid = [];
  const inputs = sudokuTable.querySelectorAll('input');
  for(let r = 0; r < 9; r++) {
    grid[r] = [];
    for(let c = 0; c < 9; c++) {
      const val = inputs[r * 9 + c].value;
      grid[r][c] = val === '' ? 0 : parseInt(val);
    }
  }

  // Check rows, cols, boxes for duplicates and missing
  let valid = true;

  // Helper: check array for duplicates ignoring zeros
  function hasDuplicates(arr) {
    const nums = arr.filter(n => n !== 0);
    return nums.length !== new Set(nums).size;
  }

  // Check rows
  for(let r = 0; r < 9; r++) {
    if(hasDuplicates(grid[r])) valid = false;
  }

  // Check cols
  for(let c = 0; c < 9; c++) {
    const col = [];
    for(let r = 0; r < 9; r++) col.push(grid[r][c]);
    if(hasDuplicates(col)) valid = false;
  }

  // Check boxes
  for(let br = 0; br < 3; br++) {
    for(let bc = 0; bc < 3; bc++) {
      const box = [];
      for(let r = 0; r < 3; r++) {
        for(let c = 0; c < 3; c++) {
          box.push(grid[br*3 + r][bc*3 + c]);
        }
      }
      if(hasDuplicates(box)) valid = false;
    }
  }

  if(!valid) {
    // Highlight errors
    // Mark inputs that violate Sudoku rules
    for(let r = 0; r < 9; r++) {
      for(let c = 0; c < 9; c++) {
        const val = grid[r][c];
        if(val === 0) continue;

        // Check row
        for(let cc = 0; cc < 9; cc++) {
          if(cc !== c && grid[r][cc] === val) {
            sudokuTable.querySelectorAll('input')[r * 9 + c].classList.add('error');
            sudokuTable.querySelectorAll('input')[r * 9 + cc].classList.add('error');
          }
        }
        // Check column
        for(let rr = 0; rr < 9; rr++) {
          if(rr !== r && grid[rr][c] === val) {
            sudokuTable.querySelectorAll('input')[r * 9 + c].classList.add('error');
            sudokuTable.querySelectorAll('input')[rr * 9 + c].classList.add('error');
          }
        }
        // Check box
        const boxStartRow = Math.floor(r/3)*3;
        const boxStartCol = Math.floor(c/3)*3;
        for(let rr = boxStartRow; rr < boxStartRow + 3; rr++) {
          for(let cc = boxStartCol; cc < boxStartCol + 3; cc++) {
            if((rr !== r || cc !== c) && grid[rr][cc] === val) {
              sudokuTable.querySelectorAll('input')[r * 9 + c].classList.add('error');
              sudokuTable.querySelectorAll('input')[rr * 9 + cc].classList.add('error');
            }
          }
        }
      }
    }
    alert("There are errors in the Sudoku grid. Please fix highlighted cells.");
  } else {
    alert("Sudoku looks good so far!");
  }
}

// ------------------
// Chess board keyboard navigation & move
// ------------------

const chessTable = document.querySelector('table.chess');
const chessCells = [...chessTable.querySelectorAll('td')];

let selectedCellIndex = 0;
let movingPieceIndex = null; // index of piece selected to move

// Helper: get row/col from index
function indexToRowCol(i) {
  return { row: Math.floor(i / 8), col: i % 8 };
}
function rowColToIndex(r,c) {
  return r * 8 + c;
}

// Highlight selection
function updateSelection() {
  chessCells.forEach(cell => cell.classList.remove('selected', 'possible-move'));
  chessCells[selectedCellIndex].classList.add('selected');
}

updateSelection();

chessTable.addEventListener('keydown', e => {
  let {row, col} = indexToRowCol(selectedCellIndex);
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    e.preventDefault();
    if(e.key === 'ArrowUp') row = (row + 7) % 8;
    else if(e.key === 'ArrowDown') row = (row + 1) % 8;
    else if(e.key === 'ArrowLeft') col = (col + 7) % 8;
    else if(e.key === 'ArrowRight') col = (col + 1) % 8;
    selectedCellIndex = rowColToIndex(row, col);
    updateSelection();
  } else if(e.key === 'Enter') {
    e.preventDefault();
    if(movingPieceIndex === null) {
      // Select piece if exists
      if(chessCells[selectedCellIndex].textContent.trim() !== '') {
        movingPieceIndex = selectedCellIndex;
        chessCells[movingPieceIndex].classList.add('possible-move');
      }
    } else {
      // Move piece if destination different and allowed (simple move, no rules)
      if(selectedCellIndex !== movingPieceIndex) {
        chessCells[selectedCellIndex].textContent = chessCells[movingPieceIndex].textContent;
        chessCells[movingPieceIndex].textContent = '';
      }
      chessCells[movingPieceIndex].classList.remove('possible-move');
      movingPieceIndex = null;
    }
  }
});
</script>

</body>
</html>
